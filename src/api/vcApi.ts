/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/no-empty-interface */
// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * VC Holder API
 * This is an Experimental Open API Specification for the [VC Data Model](https://www.w3.org/TR/vc-data-model/).
 *
 * OpenAPI spec version: 0.0.3-unstable
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url';
import * as isomorphicFetch from 'isomorphic-fetch';
import { Configuration } from './configuration';

const BASE_PATH = '/'.replace(/\/+$/, '');

/**
 *
 * @export
 */
export enum GovernmentAgency {
  Kadaster = 'brk',
  BRP = 'brp',
}

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch,
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError';
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 * A JSON-LD Verifiable Credential without a proof.
 * @export
 * @interface Credential
 */
export interface Credential {
  /**
   * The JSON-LD context of the credential.
   * @type {Array<string>}
   * @memberof Credential
   */
  context?: Array<string>;
  /**
   * The ID of the credential.
   * @type {string}
   * @memberof Credential
   */
  id?: string;
  /**
   * The JSON-LD type of the credential.
   * @type {Array<string>}
   * @memberof Credential
   */
  type?: Array<string>;
  /**
   *
   * @type {Issuer}
   * @memberof Credential
   */
  issuer?: Issuer;
  /**
   * The issuanceDate
   * @type {string}
   * @memberof Credential
   */
  issuanceDate?: string;
  /**
   * The expirationDate
   * @type {string}
   * @memberof Credential
   */
  expirationDate?: string;
  /**
   * The subject
   * @type {any}
   * @memberof Credential
   */
  credentialSubject?: any;
}
/**
 * Options for specifying how the derived credential is created.
 * @export
 * @interface DeriveCredentialOptions
 */
export interface DeriveCredentialOptions {
  /**
   * An encoded nonce provided by the holder of the credential to be included into the LinkedDataProof.
   * @type {string}
   * @memberof DeriveCredentialOptions
   */
  nonce?: string;
}
/**
 *
 * @export
 * @interface DeriveCredentialRequest
 */
export interface DeriveCredentialRequest {
  /**
   *
   * @type {VerifiableCredential}
   * @memberof DeriveCredentialRequest
   */
  verifiableCredential?: VerifiableCredential;
  /**
   * A JSON-LD frame used for selective disclosure.
   * @type {any}
   * @memberof DeriveCredentialRequest
   */
  frame?: any;
  /**
   *
   * @type {DeriveCredentialOptions}
   * @memberof DeriveCredentialRequest
   */
  options?: DeriveCredentialOptions;
}
/**
 *
 * @export
 * @interface DeriveCredentialResponse
 */
export interface DeriveCredentialResponse {}
/**
 * A response that denotes that an error has occurred.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponse
   */
  message: string;
  /**
   *
   * @type {any}
   * @memberof ErrorResponse
   */
  details?: any;
}
/**
 *
 * @export
 * @interface Id
 */
export interface Id {}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {}
/**
 * Options for specifying how the LinkedDataProof is created.
 * @export
 * @interface IssueCredentialOptions
 */
export interface IssueCredentialOptions {
  /**
   * The date and time of the proof (with a maximum accuracy in seconds). Default current system time.
   * @type {string}
   * @memberof IssueCredentialOptions
   */
  created?: string;
  /**
   * A challenge provided by the requesting party of the proof. For example 6e62f66e-67de-11eb-b490-ef3eeefa55f2
   * @type {string}
   * @memberof IssueCredentialOptions
   */
  challenge?: string;
  /**
   * The intended domain of validity for the proof. For example website.example
   * @type {string}
   * @memberof IssueCredentialOptions
   */
  domain?: string;
  /**
   *
   * @type {IssueCredentialOptionsCredentialStatus}
   * @memberof IssueCredentialOptions
   */
  credentialStatus?: IssueCredentialOptionsCredentialStatus;
}
/**
 * The method of credential status to issue the credential including. If omitted credential status will be included.
 * @export
 * @interface IssueCredentialOptionsCredentialStatus
 */
export interface IssueCredentialOptionsCredentialStatus {
  /**
   * The type of credential status to issue the credential with
   * @type {string}
   * @memberof IssueCredentialOptionsCredentialStatus
   */
  type?: string;
}
/**
 *
 * @export
 * @interface IssueCredentialRequest
 */
export interface IssueCredentialRequest {
  /**
   *
   * @type {Credential}
   * @memberof IssueCredentialRequest
   */
  credential?: Credential;
  /**
   *
   * @type {IssueCredentialOptions}
   * @memberof IssueCredentialRequest
   */
  options?: IssueCredentialOptions;
}
/**
 *
 * @export
 * @interface IssueCredentialResponse
 */
export interface IssueCredentialResponse {
  /**
   *
   * @type {VerifiableCredential}
   * @memberof IssueCredentialResponse
   */
  verifiableCredential?: VerifiableCredential;
}
/**
 * A JSON-LD Verifiable Credential Issuer.
 * @export
 * @interface Issuer
 */
export interface Issuer {}
/**
 * A JSON-LD Linked Data proof.
 * @export
 * @interface LinkedDataProof
 */
export interface LinkedDataProof {
  /**
   * Linked Data Signature Suite used to produce proof.
   * @type {string}
   * @memberof LinkedDataProof
   */
  type?: string;
  /**
   * Date the proof was created.
   * @type {string}
   * @memberof LinkedDataProof
   */
  created?: string;
  /**
   * A value chosen by the verifier to mitigate authentication proof replay attacks.
   * @type {string}
   * @memberof LinkedDataProof
   */
  challenge?: string;
  /**
   * The domain of the proof to restrict its use to a particular target.
   * @type {string}
   * @memberof LinkedDataProof
   */
  domain?: string;
  /**
   * A value chosen by the creator of a proof to randomize proof values for privacy purposes.
   * @type {string}
   * @memberof LinkedDataProof
   */
  nonce?: string;
  /**
   * Verification Method used to verify proof.
   * @type {string}
   * @memberof LinkedDataProof
   */
  verificationMethod?: string;
  /**
   * The purpose of the proof to be used with verificationMethod.
   * @type {string}
   * @memberof LinkedDataProof
   */
  proofPurpose?: string;
  /**
   * Detached JSON Web Signature.
   * @type {string}
   * @memberof LinkedDataProof
   */
  jws?: string;
  /**
   * Value of the Linked Data proof.
   * @type {string}
   * @memberof LinkedDataProof
   */
  proofValue?: string;
}
/**
 *
 * @export
 * @interface NotifyPresentationAvailableRequest
 */
export interface NotifyPresentationAvailableRequest {
  /**
   *
   * @type {NotifyPresentationAvailableRequestQuery}
   * @memberof NotifyPresentationAvailableRequest
   */
  query?: NotifyPresentationAvailableRequestQuery;
}
/**
 * See https://w3c-ccg.github.io/vp-request-spec/#format
 * @export
 * @interface NotifyPresentationAvailableRequestQuery
 */
export interface NotifyPresentationAvailableRequestQuery {
  /**
   * The type of query the server should reply with.
   * @type {string}
   * @memberof NotifyPresentationAvailableRequestQuery
   */
  type?: string;
  /**
   * Details of the client's available presentation
   * @type {any}
   * @memberof NotifyPresentationAvailableRequestQuery
   */
  credentialQuery?: any;
}
/**
 *
 * @export
 * @interface NotifyPresentationAvailableResponse
 */
export interface NotifyPresentationAvailableResponse {
  /**
   * See https://w3c-ccg.github.io/vp-request-spec/#format
   * @type {any}
   * @memberof NotifyPresentationAvailableResponse
   */
  query?: any;
  /**
   * See https://w3id.org/security#domain
   * @type {string}
   * @memberof NotifyPresentationAvailableResponse
   */
  domain?: string;
  /**
   * See https://w3id.org/security#challenge
   * @type {string}
   * @memberof NotifyPresentationAvailableResponse
   */
  challenge?: string;
}
/**
 * Options for specifying how the LinkedDataProof is created.
 * @export
 * @interface PresentCredentialOptions
 */
export interface PresentCredentialOptions {
  /**
   * The type of the proof. Default is an appropriate proof type corresponding to the verification method.
   * @type {string}
   * @memberof PresentCredentialOptions
   */
  type?: string;
  /**
   * The URI of the verificationMethod used for the proof. If omitted, a default verification method will be used.
   * @type {string}
   * @memberof PresentCredentialOptions
   */
  verificationMethod?: string;
  /**
   * The purpose of the proof. Default 'assertionMethod'.
   * @type {string}
   * @memberof PresentCredentialOptions
   */
  proofPurpose?: string;
  /**
   * The date and time of the proof (with a maximum accuracy in seconds). Default current system time.
   * @type {string}
   * @memberof PresentCredentialOptions
   */
  created?: string;
  /**
   * A challenge provided by the requesting party of the proof. For example 6e62f66e-67de-11eb-b490-ef3eeefa55f2
   * @type {string}
   * @memberof PresentCredentialOptions
   */
  challenge?: string;
  /**
   * The intended domain of validity for the proof. For example website.example
   * @type {string}
   * @memberof PresentCredentialOptions
   */
  domain?: string;
}
/**
 * A JSON-LD Verifiable Presentation without a proof.
 * @export
 * @interface Presentation
 */
export interface Presentation {
  /**
   * The JSON-LD context of the presentation.
   * @type {Array<string>}
   * @memberof Presentation
   */
  context?: Array<string>;
  /**
   * The ID of the presentation.
   * @type {string}
   * @memberof Presentation
   */
  id?: string;
  /**
   * The JSON-LD type of the presentation.
   * @type {Array<string>}
   * @memberof Presentation
   */
  type?: Array<string>;
  /**
   * The holder - will be ignored if no proof is present since there is no proof of authority over the credentials
   * @type {any}
   * @memberof Presentation
   */
  holder?: any;
  /**
   * The Verifiable Credentials
   * @type {Array<VerifiableCredential>}
   * @memberof Presentation
   */
  verifiableCredential?: Array<VerifiableCredential>;
}
/**
 *
 * @export
 * @interface PresentationsVerifyBody
 */
export interface PresentationsVerifyBody {}
/**
 *
 * @export
 * @interface ProoflessVerifyPresentationRequest
 */
export interface ProoflessVerifyPresentationRequest {
  /**
   *
   * @type {Presentation}
   * @memberof ProoflessVerifyPresentationRequest
   */
  presentation?: Presentation;
}
/**
 *
 * @export
 * @interface ProvePresentationRequest
 */
export interface ProvePresentationRequest {
  /**
   *
   * @type {Presentation}
   * @memberof ProvePresentationRequest
   */
  presentation?: Presentation;
  /**
   *
   * @type {PresentCredentialOptions}
   * @memberof ProvePresentationRequest
   */
  options?: PresentCredentialOptions;
}
/**
 *
 * @export
 * @interface ProvePresentationResponse
 */
export interface ProvePresentationResponse {
  /**
   *
   * @type {VerifiablePresentation}
   * @memberof ProvePresentationResponse
   */
  verifiablePresentation?: VerifiablePresentation;
}
/**
 *
 * @export
 * @interface StorePresentationRequest
 */
export interface StorePresentationRequest {}
/**
 * Request for updating the status of an issued credential.
 * @export
 * @interface UpdateCredentialStatus
 */
export interface UpdateCredentialStatus {
  /**
   *
   * @type {string}
   * @memberof UpdateCredentialStatus
   */
  credentialId?: string;
  /**
   *
   * @type {Array<UpdateCredentialStatusCredentialStatus>}
   * @memberof UpdateCredentialStatus
   */
  credentialStatus?: Array<UpdateCredentialStatusCredentialStatus>;
}
/**
 *
 * @export
 * @interface UpdateCredentialStatusCredentialStatus
 */
export interface UpdateCredentialStatusCredentialStatus {
  /**
   *
   * @type {string}
   * @memberof UpdateCredentialStatusCredentialStatus
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateCredentialStatusCredentialStatus
   */
  status?: string;
}
/**
 * A JSON-LD Verifiable Credential with a proof.
 * @export
 * @interface VerifiableCredential
 */
export interface VerifiableCredential extends Credential {
  /**
   *
   * @type {LinkedDataProof}
   * @memberof VerifiableCredential
   */
  proof?: LinkedDataProof;
}
/**
 * A JSON-LD Verifiable Presentation with a proof.
 * @export
 * @interface VerifiablePresentation
 */
export interface VerifiablePresentation extends Presentation {
  /**
   *
   * @type {LinkedDataProof}
   * @memberof VerifiablePresentation
   */
  proof?: LinkedDataProof;
}
/**
 * A Verifiable Presentation Request.
 * @export
 * @interface VerifiablePresentationRequest
 */
export interface VerifiablePresentationRequest {
  /**
   * A set of one or more queries sent by the requester.
   * @type {Array<VerifiablePresentationRequestQuery>}
   * @memberof VerifiablePresentationRequest
   */
  query?: Array<VerifiablePresentationRequestQuery>;
  /**
   * A challenge, intended to prevent replay attacks, provided by the requester that is typically expected to be included in the Verifiable Presentation response.
   * @type {string}
   * @memberof VerifiablePresentationRequest
   */
  challenge?: string;
  /**
   * A domain, intended to prevent replay attacks, provided by the requester that is typically expected to be included in the Verifiable Presentation response.
   * @type {Array<string>}
   * @memberof VerifiablePresentationRequest
   */
  domain?: Array<string>;
  /**
   * A list of interaction mechanisms that are supported by the server.
   * @type {Array<VerifiablePresentationRequestInteract>}
   * @memberof VerifiablePresentationRequest
   */
  interact?: Array<VerifiablePresentationRequestInteract>;
}
/**
 *
 * @export
 * @interface VerifiablePresentationRequestInteract
 */
export interface VerifiablePresentationRequestInteract {
  /**
   *
   * @type {VerifiablePresentationRequestService}
   * @memberof VerifiablePresentationRequestInteract
   */
  service?: VerifiablePresentationRequestService;
}
/**
 *
 * @export
 * @interface VerifiablePresentationRequestQuery
 */
export interface VerifiablePresentationRequestQuery {
  /**
   * The type of the query.
   * @type {Array<string>}
   * @memberof VerifiablePresentationRequestQuery
   */
  type?: Array<string>;
}
/**
 * A service that is supported by the server that is capable of receiving a response to the Verifiable Presentation Request.
 * @export
 * @interface VerifiablePresentationRequestService
 */
export interface VerifiablePresentationRequestService {
  /**
   * The type of the service.
   * @type {Array<string>}
   * @memberof VerifiablePresentationRequestService
   */
  type?: Array<string>;
  /**
   * A URL that can be utilized for interacting with the service for the purposes of responding to the Verifiable Presentation Request.
   * @type {string}
   * @memberof VerifiablePresentationRequestService
   */
  serviceEndpoint?: string;
}
/**
 *
 * @export
 * @interface VerifiablePresentationResponse
 */
export interface VerifiablePresentationResponse {
  /**
   *
   * @type {VerifiablePresentation}
   * @memberof VerifiablePresentationResponse
   */
  verifiablePresentation?: VerifiablePresentation;
}
/**
 * Object summarizing a verification
 * @export
 * @interface VerificationResult
 */
export interface VerificationResult {
  /**
   * The checks performed
   * @type {Array<string>}
   * @memberof VerificationResult
   */
  checks?: Array<string>;
  /**
   * Warnings
   * @type {Array<string>}
   * @memberof VerificationResult
   */
  warnings?: Array<string>;
  /**
   * Errors
   * @type {Array<string>}
   * @memberof VerificationResult
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface VerifyCredentialRequest
 */
export interface VerifyCredentialRequest {
  /**
   *
   * @type {VerifiableCredential}
   * @memberof VerifyCredentialRequest
   */
  verifiableCredential?: VerifiableCredential;
  /**
   *
   * @type {VerifyOptions}
   * @memberof VerifyCredentialRequest
   */
  options?: VerifyOptions;
}
/**
 *
 * @export
 * @interface VerifyCredentialResponse
 */
export interface VerifyCredentialResponse {}
/**
 * Options for specifying how the LinkedDataProof is verified.
 * @export
 * @interface VerifyOptions
 */
export interface VerifyOptions {
  /**
   * A challenge provided by the requesting party of the proof. For example 6e62f66e-67de-11eb-b490-ef3eeefa55f2
   * @type {string}
   * @memberof VerifyOptions
   */
  challenge?: string;
  /**
   * The intended domain of validity for the proof. For example website.example
   * @type {string}
   * @memberof VerifyOptions
   */
  domain?: string;
}
/**
 *
 * @export
 * @interface VerifyPresentationRequest
 */
export interface VerifyPresentationRequest {
  /**
   *
   * @type {VerifiablePresentation}
   * @memberof VerifyPresentationRequest
   */
  verifiablePresentation?: VerifiablePresentation;
  /**
   *
   * @type {VerifyOptions}
   * @memberof VerifyPresentationRequest
   */
  options?: VerifyOptions;
}
/**
 *
 * @export
 * @interface VerifyPresentationResponse
 */
export interface VerifyPresentationResponse {}
/**
 * HolderCredentialsApi - fetch parameter creator
 * @export
 */
export const HolderCredentialsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Deletes a credential or verifiable credential by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(id: Id, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteCredential.',
        );
      }
      const localVarPath = `/credentials/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Derives a credential and returns it in the response body.
     * @summary Derives a credential and returns it in the response body.
     * @param {DeriveCredentialRequest} [body] Parameters for deriving the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deriveCredential(
      body?: DeriveCredentialRequest,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/credentials/derive`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'DeriveCredentialRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a credential or verifiable credential by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(id: Id, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getCredential.',
        );
      }
      const localVarPath = `/credentials/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets list of credentials or verifiable credentials
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredentials(type?: Array<string>, options: any = {}): FetchArgs {
      const localVarPath = `/credentials`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter['type'] = type;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HolderCredentialsApi - functional programming interface
 * @export
 */
export const HolderCredentialsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Deletes a credential or verifiable credential by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(
      id: Id,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = HolderCredentialsApiFetchParamCreator(
        configuration,
      ).deleteCredential(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Derives a credential and returns it in the response body.
     * @summary Derives a credential and returns it in the response body.
     * @param {DeriveCredentialRequest} [body] Parameters for deriving the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deriveCredential(
      body?: DeriveCredentialRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<VerifiableCredential> {
      const localVarFetchArgs = HolderCredentialsApiFetchParamCreator(
        configuration,
      ).deriveCredential(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets a credential or verifiable credential by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(
      id: Id,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs = HolderCredentialsApiFetchParamCreator(
        configuration,
      ).getCredential(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets list of credentials or verifiable credentials
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredentials(
      type?: Array<string>,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<VerifiableCredential | Credential>> {
      const localVarFetchArgs = HolderCredentialsApiFetchParamCreator(
        configuration,
      ).getCredentials(type, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * HolderCredentialsApi - factory interface
 * @export
 */
export const HolderCredentialsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Deletes a credential or verifiable credential by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCredential(id: Id, options?: any) {
      return HolderCredentialsApiFp(configuration).deleteCredential(
        id,
        options,
      )(fetch, basePath);
    },
    /**
     * Derives a credential and returns it in the response body.
     * @summary Derives a credential and returns it in the response body.
     * @param {DeriveCredentialRequest} [body] Parameters for deriving the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deriveCredential(body?: DeriveCredentialRequest, options?: any) {
      return HolderCredentialsApiFp(configuration).deriveCredential(
        body,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets a credential or verifiable credential by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredential(id: Id, options?: any) {
      return HolderCredentialsApiFp(configuration).getCredential(id, options)(
        fetch,
        basePath,
      );
    },
    /**
     *
     * @summary Gets list of credentials or verifiable credentials
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCredentials(type?: Array<string>, options?: any) {
      return HolderCredentialsApiFp(configuration).getCredentials(
        type,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * HolderCredentialsApi - object-oriented interface
 * @export
 * @class HolderCredentialsApi
 * @extends {BaseAPI}
 */
export class HolderCredentialsApi extends BaseAPI {
  /**
   *
   * @summary Deletes a credential or verifiable credential by ID
   * @param {Id} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HolderCredentialsApi
   */
  public deleteCredential(id: Id, options?: any) {
    return HolderCredentialsApiFp(this.configuration).deleteCredential(
      id,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Derives a credential and returns it in the response body.
   * @summary Derives a credential and returns it in the response body.
   * @param {DeriveCredentialRequest} [body] Parameters for deriving the credential.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HolderCredentialsApi
   */
  public deriveCredential(body?: DeriveCredentialRequest, options?: any) {
    return HolderCredentialsApiFp(this.configuration).deriveCredential(
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets a credential or verifiable credential by ID
   * @param {Id} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HolderCredentialsApi
   */
  public getCredential(id: Id, options?: any) {
    return HolderCredentialsApiFp(this.configuration).getCredential(
      id,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets list of credentials or verifiable credentials
   * @param {Array<string>} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HolderCredentialsApi
   */
  public getCredentials(type?: Array<string>, options?: any) {
    return HolderCredentialsApiFp(this.configuration).getCredentials(
      type,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * HolderPresentationsApi - fetch parameter creator
 * @export
 */
export const HolderPresentationsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Deletes a presentation or verifiable presentation by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePresentation(id: Id, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deletePresentation.',
        );
      }
      const localVarPath = `/presentations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: 'DELETE' },
        options,
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a presentation or verifiable presentation by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPresentation(id: Id, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getPresentation.',
        );
      }
      const localVarPath = `/presentations/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets list of presentations or verifiable presentations
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPresentations(type?: Array<string>, options: any = {}): FetchArgs {
      const localVarPath = `/presentations`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (type) {
        localVarQueryParameter['type'] = type;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Proves a presentation and returns it in the response body.
     * @summary Proves a presentation and returns it in the response body.
     * @param {ProvePresentationRequest} [body] Parameters for proving the presentation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    provePresentation(
      body?: ProvePresentationRequest,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/presentations/prove`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'ProvePresentationRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HolderPresentationsApi - functional programming interface
 * @export
 */
export const HolderPresentationsApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Deletes a presentation or verifiable presentation by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePresentation(
      id: Id,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = HolderPresentationsApiFetchParamCreator(
        configuration,
      ).deletePresentation(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets a presentation or verifiable presentation by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPresentation(
      id: Id,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
      const localVarFetchArgs = HolderPresentationsApiFetchParamCreator(
        configuration,
      ).getPresentation(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @summary Gets list of presentations or verifiable presentations
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPresentations(
      type?: Array<string>,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<Array<Presentation | VerifiablePresentation>> {
      const localVarFetchArgs = HolderPresentationsApiFetchParamCreator(
        configuration,
      ).getPresentations(type, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Proves a presentation and returns it in the response body.
     * @summary Proves a presentation and returns it in the response body.
     * @param {ProvePresentationRequest} [body] Parameters for proving the presentation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    provePresentation(
      body?: ProvePresentationRequest,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<ProvePresentationResponse> {
      const localVarFetchArgs = HolderPresentationsApiFetchParamCreator(
        configuration,
      ).provePresentation(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * HolderPresentationsApi - factory interface
 * @export
 */
export const HolderPresentationsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     *
     * @summary Deletes a presentation or verifiable presentation by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePresentation(id: Id, options?: any) {
      return HolderPresentationsApiFp(configuration).deletePresentation(
        id,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets a presentation or verifiable presentation by ID
     * @param {Id} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPresentation(id: Id, options?: any) {
      return HolderPresentationsApiFp(configuration).getPresentation(
        id,
        options,
      )(fetch, basePath);
    },
    /**
     *
     * @summary Gets list of presentations or verifiable presentations
     * @param {Array<string>} [type]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPresentations(type?: Array<string>, options?: any) {
      return HolderPresentationsApiFp(configuration).getPresentations(
        type,
        options,
      )(fetch, basePath);
    },
    /**
     * Proves a presentation and returns it in the response body.
     * @summary Proves a presentation and returns it in the response body.
     * @param {ProvePresentationRequest} [body] Parameters for proving the presentation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    provePresentation(body?: ProvePresentationRequest, options?: any) {
      return HolderPresentationsApiFp(configuration).provePresentation(
        body,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * HolderPresentationsApi - object-oriented interface
 * @export
 * @class HolderPresentationsApi
 * @extends {BaseAPI}
 */
export class HolderPresentationsApi extends BaseAPI {
  /**
   *
   * @summary Deletes a presentation or verifiable presentation by ID
   * @param {Id} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HolderPresentationsApi
   */
  public deletePresentation(id: Id, options?: any) {
    return HolderPresentationsApiFp(this.configuration).deletePresentation(
      id,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets a presentation or verifiable presentation by ID
   * @param {Id} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HolderPresentationsApi
   */
  public getPresentation(id: Id, options?: any) {
    return HolderPresentationsApiFp(this.configuration).getPresentation(
      id,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @summary Gets list of presentations or verifiable presentations
   * @param {Array<string>} [type]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HolderPresentationsApi
   */
  public getPresentations(type?: Array<string>, options?: any) {
    return HolderPresentationsApiFp(this.configuration).getPresentations(
      type,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Proves a presentation and returns it in the response body.
   * @summary Proves a presentation and returns it in the response body.
   * @param {ProvePresentationRequest} [body] Parameters for proving the presentation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HolderPresentationsApi
   */
  public provePresentation(body?: ProvePresentationRequest, options?: any) {
    return HolderPresentationsApiFp(this.configuration).provePresentation(
      body,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * IssuerCredentialsApi - fetch parameter creator
 * @export
 */
export const IssuerCredentialsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Issues a credential and returns it in the response body.
     * @summary Issues a credential and returns it in the response body.
     * @param {string} agency The government agency the user requires a VC from
     * @param {IssueCredentialRequest} [body] Parameters for issuing the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueCredential(
      agency: string,
      body?: IssueCredentialRequest,
      options: any = {},
    ): FetchArgs {
      // verify required parameter 'agency' is not null or undefined
      if (agency === null || agency === undefined) {
        throw new RequiredError(
          'agency',
          'Required parameter agency was null or undefined when calling issueCredential.',
        );
      }
      const localVarPath = `/{agency}/credentials/issue`.replace(
        `{${'agency'}}`,
        encodeURIComponent(String(agency)),
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'IssueCredentialRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates the status of an issued credential.
     * @summary Updates the status of an issued credential
     * @param {UpdateCredentialStatus} [body] Parameters for updating the status of the issued credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredentialStatus(
      body?: UpdateCredentialStatus,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/credentials/status`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'UpdateCredentialStatus' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IssuerCredentialsApi - functional programming interface
 * @export
 */
export const IssuerCredentialsApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Issues a credential and returns it in the response body.
     * @summary Issues a credential and returns it in the response body.
     * @param {string} agency The government agency the user requires a VC from
     * @param {IssueCredentialRequest} [body] Parameters for issuing the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueCredential(
      agency: string,
      body?: IssueCredentialRequest,
      options?: any,
    ): (
      fetch?: FetchAPI,
      basePath?: string,
    ) => Promise<IssueCredentialResponse> {
      const localVarFetchArgs = IssuerCredentialsApiFetchParamCreator(
        configuration,
      ).issueCredential(agency, body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Updates the status of an issued credential.
     * @summary Updates the status of an issued credential
     * @param {UpdateCredentialStatus} [body] Parameters for updating the status of the issued credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredentialStatus(
      body?: UpdateCredentialStatus,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = IssuerCredentialsApiFetchParamCreator(
        configuration,
      ).updateCredentialStatus(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * IssuerCredentialsApi - factory interface
 * @export
 */
export const IssuerCredentialsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Issues a credential and returns it in the response body.
     * @summary Issues a credential and returns it in the response body.
     * @param {string} agency The government agency the user requires a VC from
     * @param {IssueCredentialRequest} [body] Parameters for issuing the credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    issueCredential(
      agency: string,
      body?: IssueCredentialRequest,
      options?: any,
    ) {
      return IssuerCredentialsApiFp(configuration).issueCredential(
        agency,
        body,
        options,
      )(fetch, basePath);
    },
    /**
     * Updates the status of an issued credential.
     * @summary Updates the status of an issued credential
     * @param {UpdateCredentialStatus} [body] Parameters for updating the status of the issued credential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCredentialStatus(body?: UpdateCredentialStatus, options?: any) {
      return IssuerCredentialsApiFp(configuration).updateCredentialStatus(
        body,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * IssuerCredentialsApi - object-oriented interface
 * @export
 * @class IssuerCredentialsApi
 * @extends {BaseAPI}
 */
export class IssuerCredentialsApi extends BaseAPI {
  /**
   * Issues a credential and returns it in the response body.
   * @summary Issues a credential and returns it in the response body.
   * @param {string} agency The government agency the user requires a VC from
   * @param {IssueCredentialRequest} [body] Parameters for issuing the credential.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IssuerCredentialsApi
   */
  public issueCredential(
    agency: string,
    body?: IssueCredentialRequest,
    options?: any,
  ) {
    return IssuerCredentialsApiFp(this.configuration).issueCredential(
      agency,
      body,
      options,
    )(this.fetch, this.basePath);
  }

  /**
   * Updates the status of an issued credential.
   * @summary Updates the status of an issued credential
   * @param {UpdateCredentialStatus} [body] Parameters for updating the status of the issued credential.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IssuerCredentialsApi
   */
  public updateCredentialStatus(body?: UpdateCredentialStatus, options?: any) {
    return IssuerCredentialsApiFp(this.configuration).updateCredentialStatus(
      body,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * VerifierCredentialsApi - fetch parameter creator
 * @export
 */
export const VerifierCredentialsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @param {VerifyCredentialRequest} [body] Parameters for verifying a verifiableCredential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCredential(
      body?: VerifyCredentialRequest,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/credentials/verify`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'VerifyCredentialRequest' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VerifierCredentialsApi - functional programming interface
 * @export
 */
export const VerifierCredentialsApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @param {VerifyCredentialRequest} [body] Parameters for verifying a verifiableCredential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCredential(
      body?: VerifyCredentialRequest,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<VerificationResult> {
      const localVarFetchArgs = VerifierCredentialsApiFetchParamCreator(
        configuration,
      ).verifyCredential(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * VerifierCredentialsApi - factory interface
 * @export
 */
export const VerifierCredentialsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
     * @param {VerifyCredentialRequest} [body] Parameters for verifying a verifiableCredential.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyCredential(body?: VerifyCredentialRequest, options?: any) {
      return VerifierCredentialsApiFp(configuration).verifyCredential(
        body,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * VerifierCredentialsApi - object-oriented interface
 * @export
 * @class VerifierCredentialsApi
 * @extends {BaseAPI}
 */
export class VerifierCredentialsApi extends BaseAPI {
  /**
   * Verifies a verifiableCredential and returns a verificationResult in the response body.
   * @summary Verifies a verifiableCredential and returns a verificationResult in the response body.
   * @param {VerifyCredentialRequest} [body] Parameters for verifying a verifiableCredential.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifierCredentialsApi
   */
  public verifyCredential(body?: VerifyCredentialRequest, options?: any) {
    return VerifierCredentialsApiFp(this.configuration).verifyCredential(
      body,
      options,
    )(this.fetch, this.basePath);
  }
}
/**
 * VerifierPresentationsApi - fetch parameter creator
 * @export
 */
export const VerifierPresentationsApiFetchParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Verifies a verifiablePresentation and returns a verificationResult in the response body.  Given the possibility of denial of service, buffer overflow, or other style attacks, an implementation is permitted to rate limit or restrict requests against this API endpoint to those requests that contain only a single credential with a 413 or 429 error code as appropriate.
     * @summary Verifies a Presentation with or without proofs attached and returns a verificationResult in the response body.
     * @param {PresentationsVerifyBody} [body] Parameters for verifying a verifiablePresentation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPresentation(
      body?: PresentationsVerifyBody,
      options: any = {},
    ): FetchArgs {
      const localVarPath = `/presentations/verify`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query,
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers,
      );
      const needsSerialization =
        <any>'PresentationsVerifyBody' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || '';

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VerifierPresentationsApi - functional programming interface
 * @export
 */
export const VerifierPresentationsApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Verifies a verifiablePresentation and returns a verificationResult in the response body.  Given the possibility of denial of service, buffer overflow, or other style attacks, an implementation is permitted to rate limit or restrict requests against this API endpoint to those requests that contain only a single credential with a 413 or 429 error code as appropriate.
     * @summary Verifies a Presentation with or without proofs attached and returns a verificationResult in the response body.
     * @param {PresentationsVerifyBody} [body] Parameters for verifying a verifiablePresentation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPresentation(
      body?: PresentationsVerifyBody,
      options?: any,
    ): (fetch?: FetchAPI, basePath?: string) => Promise<VerificationResult> {
      const localVarFetchArgs = VerifierPresentationsApiFetchParamCreator(
        configuration,
      ).verifyPresentation(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH,
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options,
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * VerifierPresentationsApi - factory interface
 * @export
 */
export const VerifierPresentationsApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string,
) {
  return {
    /**
     * Verifies a verifiablePresentation and returns a verificationResult in the response body.  Given the possibility of denial of service, buffer overflow, or other style attacks, an implementation is permitted to rate limit or restrict requests against this API endpoint to those requests that contain only a single credential with a 413 or 429 error code as appropriate.
     * @summary Verifies a Presentation with or without proofs attached and returns a verificationResult in the response body.
     * @param {PresentationsVerifyBody} [body] Parameters for verifying a verifiablePresentation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyPresentation(body?: PresentationsVerifyBody, options?: any) {
      return VerifierPresentationsApiFp(configuration).verifyPresentation(
        body,
        options,
      )(fetch, basePath);
    },
  };
};

/**
 * VerifierPresentationsApi - object-oriented interface
 * @export
 * @class VerifierPresentationsApi
 * @extends {BaseAPI}
 */
export class VerifierPresentationsApi extends BaseAPI {
  /**
   * Verifies a verifiablePresentation and returns a verificationResult in the response body.  Given the possibility of denial of service, buffer overflow, or other style attacks, an implementation is permitted to rate limit or restrict requests against this API endpoint to those requests that contain only a single credential with a 413 or 429 error code as appropriate.
   * @summary Verifies a Presentation with or without proofs attached and returns a verificationResult in the response body.
   * @param {PresentationsVerifyBody} [body] Parameters for verifying a verifiablePresentation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VerifierPresentationsApi
   */
  public verifyPresentation(body?: PresentationsVerifyBody, options?: any) {
    return VerifierPresentationsApiFp(this.configuration).verifyPresentation(
      body,
      options,
    )(this.fetch, this.basePath);
  }
}
